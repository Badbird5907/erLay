#!/usr/bin/env python3

# yes this is generated by ai
import re
from datetime import datetime

README_PATH = "README.md"


def remove_total_time_block(readme_text):
    """
    Removes the first occurrence of the "# Total Time" block from the text.

    The block is assumed to start with `# Total Time` and go until the next
    header or end-of-file.
    """
    pattern = re.compile(
        r"^# Total Time\s*\n(?:.*\n)+?(?=^#|\Z)", re.MULTILINE
    )
    return pattern.sub("", readme_text, count=1)


def parse_logged_times(readme_text):
    """
    Scans through the text (excluding the previous auto-generated totals)
    and returns a dictionary with total hours per person.

    Assumes daily log entries look like:
      ...
      Aaron: 4h
      Evan: 2h
    """
    totals = {}
    # pattern to match lines like: "Aaron: 4h" or "Evan: 2h"; leading spaces allowed
    pattern = re.compile(r"^\s*([A-Za-z]+):\s*(\d+\.?\d*)h", re.IGNORECASE)
    for line in readme_text.splitlines():
        match = pattern.match(line)
        if match:
            name = match.group(1)
            try:
                hours = float(match.group(2))
            except ValueError:
                continue
            totals[name] = totals.get(name, 0) + hours
    return totals


def format_hours(hours):
    """
    Format the hours value. If it ends with .0, it is truncated.
    """
    if hours.is_integer():
        return f"{int(hours)}h"
    else:
        return f"{hours:.1f}h"


def update_total_time_block(readme_text, totals):
    """
    Replaces the block after the "# Total Time" header with the updated total
    time entries. The block is expected to appear as:

    # Total Time

    Aaron: <auto>
    Evan: <auto>

    If the same header exists further down (e.g. individual date logs), only the
    first occurrence is modified.
    """
    header_pattern = re.compile(
        r"(?P<before>^# Total Time\s*\n)(?P<block>(?:.*\n)+?)(?=^#|\Z)",
        re.MULTILINE,
    )

    def replacement(match):
        before = match.group("before")
        # Get the block lines
        lines = match.group("block").splitlines()
        new_lines = []
        for line in lines:
            person_match = re.match(r"^([A-Za-z]+):", line)
            if person_match:
                name = person_match.group(1)
                hours = totals.get(name, 0)
                new_lines.append(f"{name}: {format_hours(hours)}")
            else:
                new_lines.append(line)
        return before + "\n".join(new_lines) + "\n"

    (new_text, count) = header_pattern.subn(replacement, readme_text, count=1)
    if count == 0:
        raise RuntimeError(
            'Could not find the "# Total Time" header block in the README.'
        )
    return new_text


def main():
    with open(README_PATH, "r", encoding="utf-8") as f:
        readme_text = f.read()

    # Remove the first "# Total Time" block to avoid counting the current auto totals
    readme_for_parsing = remove_total_time_block(readme_text)

    # Parse all daily logged times in the remaining file text
    totals = parse_logged_times(readme_for_parsing)

    # Update the total time block in the original README content
    new_readme_text = update_total_time_block(readme_text, totals)

    if new_readme_text != readme_text:
        with open(README_PATH, "w", encoding="utf-8") as f:
            f.write(new_readme_text)
        print(f"{datetime.now()}: Updated total times: {totals}")
    else:
        print(f"{datetime.now()}: No changes in total time.")


if __name__ == "__main__":
    main()

